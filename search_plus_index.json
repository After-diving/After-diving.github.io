{"./":{"url":"./","title":"Contents","keywords":"","body":"Contents HTML Basic HTML Basic Learning CSS Basic Learning Applied Visual Design.md Applied Accessibility.md Miscellaneous Markdown Syntax Summary JavaScript basic learning java Learning python basic ADB command vimrc "},"HTML_Introduce/HTML_Basic_Learning.html":{"url":"HTML_Introduce/HTML_Basic_Learning.html","title":"HTML Basic Learning","keywords":"","body":"HTML basic learning 开篇 声明HTML 文档的文档类型 可以通过来告诉浏览器你使用的是 HTML 的哪个版本，\"...\" 部分就是版本的数字信息。对应的就是 HTML5。!和大写的DOCTYPE是很重要的，特别是对于老的浏览器。但html大写小写都可以。接下来，所有的 HTML 代码都必须位于html标签中。其中位于的后面，位于网页的结尾。 HTML 书写结构 html的结构主要分为两大部分：head、body。关于网页的描述都应该放入head标签，网页的内容都应该放入body标签。 比如link、meta、title和style都应该放入head标签 标题 title ... ........ up to h6 段落 p 是 paragraph 的缩写,通常用来创建一个段落. This is a paragraph ! This is a paragraph ! Web 开发者通常用 lorem ipsum text 来做占位符，占位符就是占着位置的一些文字，没有实际意义。 为什么叫lorem ipsum text呢?是因为lorem ipsum是古罗马西塞罗谚语的前两个单词。从公元16世纪开始lorem ipsum text就被当做占位符了，这种传统延续到了互联网时代。 注释 注释是为了给代码添加说明, 方便团队合作和自己阅读, 但又不影响代码本身. HTML中, 注释标记为 This is a paragraph ! --> 列表 有序列表 HTML 有一个特定的元素用于创建有序列表ordered lists（缩写 ol）. 有序列表以开始，中间包含一个或多个元素，最后以结尾。 第一个序列 第二个序列 第一个序列 第二个序列 无序列表 HTML 有一个特定的元素用于创建有序列表unordered lists（缩写 ul）. 有序列表以开始，中间包含一个或多个元素，最后以结尾。 第一个序列 第二个序列 第一个序列 第二个序列 输入框 可以使用form创建一个表单, 用input输入框获取用户输入. Placeholder占位符是用户在input输入框中输入任何东西前的预定义文本. 通过给form表单添加一个action属性，你可以使用纯 HTML 来构建向服务器提交数据的 Web 表单. 表单添加一个submit提交按钮，当点击提交按钮时，表单中的数据将会被发送到action属性指定的地址上. 在input元素中加上required属性就实现此输入框是必填项 提交 提交 单选按钮 radio buttons（单选按钮）就好比单项选择题，正确答案只有一个。 单选按钮只是input输入框的一种类型。 每一个单选按钮都应该嵌套在它自己的label（标签）元素中。 所有关联的单选按钮应该拥有相同的name属性。 在label元素上设置for属性，让其值与单选按钮的id属性值相等，这样就在label元素和它的子元素单选按钮之间创建了一种链接关系 group1 复选框 checkbox（复选框）就好比多项选择题，正确答案有多个。 复选框是input输入框的另一种类型。 每一个复选框都应该嵌套在它自己的label（标签）元素中。 所有关联的复选框应该拥有相同的name属性。 最佳实践是在label元素上设置for属性，让其值与复选框的id属性值相等，这样就在label元素和它的子元素复选框之间创建了一种链接关系 group1 通过添加checked属性，你可以设置某个单选按钮或多选按钮被默认选中。 为此，只需给input元素添加 \"checked\" 属性 元素嵌套 div元素，也叫division（层）元素，是一个盛装其他元素的通用容器。 它也是 HTML 中出现频率最高的元素。 和其他普通元素一样, 你可以用来标记一个div元素的开始，用来标记一个div元素的结束。 HTML5 元素介绍 HTML5 引入了很多更具描述性的 HTML 元素，例如：header、footer、nav、video、article、section等等。 这些元素让 HTML 更易读，同时有助于搜索引擎优化和无障碍访问。 main元素 main元素让搜索引擎和开发者瞬间就能找到网页的主要内容。 ... ... img元素 img元素为网站添加图片, 其中src属性指向一个图片的地址 注 : img元素是没有结束标记的 所有img元素必须有alt属性, alt属性文本时图片无法加载时显示的替代文本. a元素 a锚点(Anchor)可以用来实现网页跳转. 锚点a需要需要一个href属性指向目的地, 他还需要锚点文本, 例如: 点击这里 点击这里 target=\"_blank\" 打开新的元素页 a锚点网页内部跳转 设置锚点的href属性值为井号#加上想跳转区域对应的id属性值，这样就可以创建一个内部跳转。id是用来描述网页元素的一个属性，它的值在整个页面中唯一。 xxxxxxxx 这是一个内部跳转演示 用#来创建固定链接 有时你想为网站添加一个锚点，但如果你还不确定要将它链接到哪儿，这时可以使用固定链接。 xxx "},"HTML_Introduce/CSS_Basic_Learning.html":{"url":"HTML_Introduce/CSS_Basic_Learning.html","title":"CSS Basic Learning","keywords":"","body":"CSS Basic Learning Introduction CSS 的全称是 Cascading Style Sheet（层叠样式表），它主要用来控制网页的样式。 注意: CSS 的选择器区分大小写, 因此要谨慎使用大写. CSS 早已被所有主流浏览器采用，它允许你轻松控制以下样式： 颜色 color 背景 background 字体 font 位置 position 显示 display 边框 border 内边距 padding 外边距 margin 行高 line-height 装饰 text-decoration 过渡 transtion 变化 transform 动画 animation 使用 CSS 样式主要有三种方式： 内联样式--你可以直接在 HTML 元素里使用style属性。 内部样式--你可以在style标签里面声明样式规则。 外部样式--你可以创建一个.css文件，然后在文件中编写样式规则，最后在文档中引用该文件。 尽管前两个方式也有人使用，但大部分开发人员更喜欢外部样式表，因为它可以将样式与元素分开，这提高了代码的可读性和重用性。 CSS 背后的思想是，通过选择器来定位 DOM（文档对象模型）的元素，然后将各种样式规则应用在元素上，从而改变元素在页面上的显示方式。 更改文本颜色 通过修改元素的style属性的color值来改变文本颜色 注:行内style最好以;来结束 注:行内style最好以;来结束 层叠样式表 当我们只需要改变元素的某个样式时，行内样式最简单直观。当我们需要同时改变元素的很多样式时，层叠样式表往往是一个更好的选择。 在代码的顶部，创建一个style声明区域： 在style样式声明区域内，可以创建一个元素选择器，应用于所有的h2元素。例如，如果你想所有h2元素变成红色，可以添加下方的样式规则： code{color: red;} 在每个元素的样式声明区域里，左右花括号{和 }一定要写全。 code{color: red;} 在每个元素的样式声明区域里，左右花括号{和 }一定要写全。 Class 选择器 CSS 的class具有可重用性，可应用于各种 HTML 元素。 一个 CSSclass声明示例，如下所示： .blue-text { color: blue; } 可以看到，我们在样式声明区域里，创建了一个名为blue-text的class选择器。 你可以将 CSSclass选择器应用到一个HTML元素里，如下所示： CatPhotoApp .blue-text{color: blue;} CatPhotoApp 注意：在style样式区域声明里，class需以.开头。而在 HTML 元素里，class属性的前面不能添加.。 元素字体 字体大小 字体大小由font-size属性控制. p{font-size: 36px;} 在每个元素的样式声明区域里，左右花括号{和 }一定要写全。 字体样式 通过font-family属性，可以设置元素里面的字体样式. p{font-family: \"Fira Code\";} 引用Google字体 h2 {font-family: Lobster,monospace;} 标题 注: 字体有空格需要加引号, 如\"Fira Code\",否则可以不用加引号, 如Lobster. 当字体不可用时, 浏览器会通过降级去找其他字体. 可以通过上面注释掉link试验. 图片大小 CSS 的width属性可以控制元素的宽度。图片的width宽度类似于字体的px（像素)值. .larger-image{width:500px;} 边框 CSS 边框具有style，color和width属性。 创建一个 5px 的红色实线边框包围一个 HTML 元素，我们可以这样做： .thin-red-border { border-color: red; border-width: 5px; border-style: solid; border-radius: 10px; } 背景色 .silver-background{background-color:silver;} xxxx ID属性设置元素 id不可以重用，只应用于一个元素上。同时，在 CSS 里，id的优先级要高于class，如果一个元素同时应用了class和id，并设置样式有冲突，会优先应用id的样式。 #cat-photo-element {background-color: green;} xxxx 注意在style标签里，声明 class 的时候必须在名字前插入.符号。同样，在声明 id 的时候，也必须在名字前插入#符号。 元素的内边距 所有的 HTML 元素基本都是以矩形为基础。 每个 HTML 元素周围的矩形空间由三个重要的属性来控制：padding（内边距），margin（外边距）和border（边框）。 padding控制着元素内容与border之间的空隙大小 CSS 允许你使用padding-top，padding-right， padding-bottom和padding-left属性来设置四个不同方向的padding值。 如果不想每次都要分别声明padding-top，padding-right，padding-bottom和padding-left属性，可以把它们汇总在padding属性里面声明，如:padding: 10px 20px 10px 20px; 顺序为顺时针 上->右->下->左 margin（外边距）控制元素的边框与其他元素之间的距离。如果你设置元素margin为负值，元素会变得更大。 CSS 允许你使用margin-top，margin-right，margin-bottom和margin-left属性来设置四个不同方向的margin值。 同样，每个方向的外边距值可以在margin属性里面汇总声明，来代替分别声明margin-top，margin-right，margin-bottom和margin-left属性的方式，代码如下：margin: 10px 20px 10px 20px;顺序为顺时针 上->右->下->左 .injected-text { margin-bottom: -25px; text-align: center; } .box { border-style: solid; border-color: black; border-width: 5px; text-align: center; } .yellow-box { background-color: yellow; padding: 10px; } .red-box { background-color: crimson; color: #fff; padding: 20px; margin: 20px; } .blue-box { background-color: blue; color: #fff; padding: 20px; margin: 10px; } margin padding padding 属性选择器 使用[attr=value]属性选择器修改复选框的样式。这个选择器使用特定的属性值来匹配和设置元素样式。例如，下面的代码会改变所有type为radio的元素的外边距。 [type='radio'] { margin: 20px 0px 20px 0px; } 室内 室外 相对单位和绝对单位 单位长度的类型可以分成 2 种，一种是相对的，一种是绝对的。绝对长度单位会接近屏幕上的实际测量值，不过不同屏幕的分辨率会存在差异，可能会导致一些误差。相对单位长度，就像em和rem，它们会依赖其他长度的值。就好像em的大小基于元素的字体的font-size值，如果你使用em单位来设置font-size值，它的值会跟随父元素的font-size值来改变。 .lang{padding:1.5em} 优先级 .pink-text { color: pink !important; } CSS变量 创建一个 CSS 变量，你只需要在变量名前添加两个破折号，并为其赋值，例子如下： --penguin-skin: gray; .pink-text { color: pink !important; --penguin-skin: gray; } 创建变量后，CSS 属性可以通过引用变量名来使用它的值。 background: var(--penguin-skin); .pink-text { color: pink !important; --penguin-skin: gray; } .right.hand{ background: var(--penguin-skin); } 使用变量来作为 CSS 属性值的时候，可以设置一个备用值来防止由于某些原因导致变量不生效的情况。 或许有些人正在使用着不支持 CSS 变量的旧浏览器，又或者，设备不支持你设置的变量值。为了防止这种情况出现，那么你可以这样写： background: var(--penguin-skin, black); 层级CSS变量 你创建的变量，不但可以在你声明变量的元素里面使用，同时也可以在该元素的子元素里面使用。这种效应称为cascading（层叠）。 因为层叠的效果，CSS 变量通常会定义在:root元素里。 就像html是body的容器一样，你也可以认为:root元素是你整个 HTML 文档的容器。 在:root创建的变量，在整个网页里面都能生效。 当你在:root里创建变量时，这些变量的作用域是整个页面。 如果在元素里创建相同的变量，会重写:root变量设置的值。 :root { --penguin-size: 300px; --penguin-skin: gray; --penguin-belly: white; --penguin-beak: orange; } .top-hand{ --penguin-belly: black; } 媒体查询更改变量 CSS 变量可以简化媒体查询的方式。 例如，当屏幕小于或大于媒体查询所设置的值，通过改变变量的值，那么应用了变量的元素样式都会得到响应修改。 可以通过缩放页面来查询是否生效. 网页地址尝试 @media (max-width: 350px) { :root { --penguin-size:200px; --penguin-skin:black; } } "},"HTML_Introduce/Applied_Visual_Design.html":{"url":"HTML_Introduce/Applied_Visual_Design.html","title":"Applied Visual Design.md","keywords":"","body":"Applied Visual Design text-align 属性 web 内容大部分都是文本。CSS 里面的text-align属性可以控制文本的对齐方式。 text-align: justify;可以让除最后一行之外的文字两端对齐，即每行的左右两端都紧贴行的边缘。 text-align: center;可以让文本居中对齐。 text-align: right;可以让文本右对齐。 text-align: left;是text-align的默认值，它可以让文本左对齐。 width 属性 你可以使用 CSS 里面的width属性来指定元素的宽度。属性值可以是相对单位（比如 em），绝对单位（比如 px），或者包含块（父元素）宽度的百分比。 height 属性 和width属性类似，你可以使用 CSS 里面的height属性来指定元素的高度。 文字属性 font-size调整文字大小. font-weight设置字体的粗细. line-height设置行间距离; margin属性居中显示 应用设计中经常需要把一个块级元素水平居中显示。一种常见的实现方式是把块级元素的margin值设置为auto。 同样的，这个方法也对图片奏效。图片默认是内联元素，但是可以通过设置其display属性为block来把它变成块级元素。 Transform scale 属性 CSS 属性transform里面的scale()函数，可以用来改变元素的显示比例。下面的例子把页面的段落元素放大了 2 倍： p { transform:scale(2); } 鼠标悬停时缩放元素 transform属性有很多函数，可以对元素进行调整大小、移动、旋转、翻转等操作。当使用伪类描述元素的指定状态如:hover时，transform属性可以方便的给元素添加交互。 p:hover { transform: scale(2.1); } skeX 属性沿X轴倾斜元素 transform属性skewX，skewX使选择的元素沿着 X 轴（横向）翻转指定的角度。 p { transform: skewX(-32deg); } skeY 属性沿Y轴倾斜元素 skewY属性使指定元素沿 Y 轴（垂直方向）翻转指定角度。 p { transform: skewY(-10deg); } rotate(-45deg);/用法和skeX,skeY一样,顺时针旋转/ iframe 属性 strong 标签加粗文本 术语：Strong => s => 加粗。 你可以使用strong标签来加粗文字。添加了strong标签后，浏览器会自动给元素应用font-weight:bold;。 u 标签下划线 术语：Underline => u => 下划线。 你可以使用u标签来给文字添加下划线。添加了u标签后，浏览器会自动给元素应用text-decoration: underline;。 em 标签强调文本 术语：emphasis => em => 强调。 你可以使用em标签来强调文本。由于浏览器会自动给元素应用font-style: italic;，所以文本会显示为斜体。 s 标签删除线 术语：Strikethrough => s => 删除线。 你可以用s标签来给文字添加删除线，我是明晃晃的删除线，它代表着这段文字不再有效。添加了s标签后，浏览器会自动给元素应用text-decoration: line-through;。 hr标签水平线 术语：Horizontal Rule => hr => 水平线。 你可以用hr标签来创建一条宽度撑满父元素的水平线。它一般用来表示文档主题的改变，在视觉上将文档分隔成几个部分。 注意: 在 HTML 里，hr是自关闭标签，所以不需要一个单独的关闭标签。 文本背景色 为了让页面更美观，除了设置整个页面的背景色以及文字颜色外，你还可以单独设置文字的背景色，即在文字的父元素上添加background-color属性。在本挑战里我们将使用rgba()颜色，而不是之前学到的hex编码或者rgb()颜色。 rgba 代表： r = red 红色 g = green 绿色 b = blue 蓝色 a = alpha 透明度 RGB 值可以在 0 到 255 之间。alpha 值可以在 0 到 1 之间，其中 0 代表完全透明，1 代表完全不透明。rgba()非常棒，因为你可以设置颜色的透明度，这意味着你可以做出一些很漂亮的半透明效果。 box-shadow 元素阴影 box-shadow属性用来给元素添加阴影，该属性值是由逗号分隔的一个或多个阴影列表。 box-shadow属性的每个阴影依次由下面这些值描述： offset-x阴影的水平偏移量； offset-y阴影的垂直偏移量; blur-radius模糊距离； spread-radius阴影尺寸； 颜色。 其中blur-raduis和spread-raduis是可选的。 box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23); 降低元素的opacity透明度 CSS 里的opacity属性用来设置元素的透明度。 值 1 代表完全不透明。 值 0.5 代表半透明。 值 0 代表完全透明。 透明度会应用到元素内的所有内容，不论是图片，还是文本，或是背景色。 .links { text-align: left; color: black; opacity: 0.7; } 百度 text-transform属性 CSS 里面的text-transform属性来改变英文中字母的大小写。它通常用来统一页面里英文的显示，且无需直接改变 HTML 元素中的文本。 下面的表格展示了text-transform的不同值对文字 “Transform me” 的影响。 Value Result Value Result lowercase \"transform me\" uppercase \"TRANSFORM ME\" capitalize \"Transform Me\" initial 使用默认值 inherit 使用父元素的text-transform值。 none Default:不改变文字。 元素的position 相对位置 在 CSS 里一切 HTML 元素皆为盒子，也就是通常所说的盒模型。块级元素自动从新的一行开始（比如标题、段落以及 div），行内元素排列在上一个元素后（比如图片以及 span）。元素默认按照这种方式布局称为文档的普通流，同时 CSS 提供了 position 属性来覆盖它。 当元素的 position 设置为relative时，它允许你通过 CSS 指定该元素在当前普通流页面下的相对偏移量。 CSS 里控制各个方向偏移量的对应的属性是left、right、top和bottom。它们代表着从原来的位置向对应的方向偏移指定的像素、百分比或者 ems。下面的例子展示了段落向上偏移 10 像素： 注: 元素将从当前位置，向属性相反的方向偏移 p { position: relative; bottom: 10px; } 绝对位置 CSSposition属性的取值选项absolute，absolute相对于其包含块定位。和relative定位不一样，absolute定位会将元素从当前的文档流里面移除，周围的元素会忽略它。可以用 CSS 的 top、bottom、left 和 right 属性来调整元素的位置。 absolute定位比较特殊的一点是元素的定位参照于最近的已定位祖先元素。如果它的父元素没有添加定位规则（默认是position:relative;）,浏览器会继续寻找直到默认的 body 标签。 #searchbar { position:absolute; top:50px; right:50px; } section { position: relative; } 欢迎！ 搜索： 固定定位 fixed定位，它是一种特殊的绝对（absolute）定位，区别是其包含块是浏览器窗口。和绝对定位类似，fixed定位使用 top、bottom、left 和 right 属性来调整元素的位置，并且会将元素从当前的文档流里面移除，其它元素会忽略它的存在。 fixed定位和absolute定位的最明显的区别是fixed定位元素不会随着屏幕滚动而移动。 folat属性 浮动元素不在文档流中，它向左或向右浮动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。通常需要用width属性来指定浮动元素占据的水平空间。 #left { float:left; width: 50%; } #right { float:right; width: 40%; } 重叠元素z-index 属性 当一些元素重叠时，在 HTML 里后出现的元素会默认显示在更早出现的元素的上面。你可以使用z-index属性指定元素的堆叠次序。z-index的取值是整数，数值大的元素优先于数值小的元素显示。 div { width: 60%; height: 200px; margin-top: 20px; } .first { background-color: red; position: absolute; z-index:2; } .second { background-color: blue; position: absolute; left: 40px; top: 50px; z-index: 1; } 色彩 了解互补色 色彩理论以及设计色彩学很复杂，这里将只涉及很基础的部分。在网站设计里，颜色能让内容更醒目，能调动情绪，从而创造舒适的视觉体验。不同的颜色组合对网站的视觉效果影响很大，精妙的设计都需要适宜的颜色来美化页面内容。 一半是科学，一半是艺术，色环是我们认识颜色关系的好工具 - 它是一个近色相邻异色相离的圆环。当两个颜色恰好在色环的两端时，这两个颜色叫做补色。绘画中两只补色在混合后会变成灰色。补色搭配能形成强列的对比效果，传达出活力、能量、兴奋等意义。 下面是一些十六进制码（hex code）补色的例子： 红色（#FF0000）和蓝绿色 (#00FFFF) 绿色（#00FF00）和品红色（#FF00FF） 蓝色（#0000FF）和黄色（#FFFF00） 了解三原色 电脑显示器和手机屏幕是一种加色模型，将红（R）、绿（G）、蓝（B）三原色的色光以不同的比例相加，以产生多种多样的色光。 两种原色相加产生二次色：蓝绿（G+B）、品红（R+B）和黄色（R+G）。这些二次色恰好是在合成它们时未使用的原色的补色，即在色环中位于两端。例如，品红色是红色和蓝色相加产生，它是绿色的补色。 三次色是由原色和二次色相加产生的颜色，例如红色（原色）和黄色（二次色）相加产生橙色。将这六种颜色中相邻的颜色相加，便产生了十二色色环。 设计里面有很多种颜色搭配方法。涉及到三次色的一种配色方法是分裂补色搭配法。选定主色之后，在色环上选择与它的补色相邻的两种颜色与之搭配。此种搭配既有对比，又不失和谐。 橙色 #FF7D00 蓝绿色 #00FFFF 树莓红 #FF007D 颜色的色相 HSL 色彩空间模型是一种将 RGB 色彩模型中的点放在圆柱坐标系中的表示法，描述了色相（hue）、饱和度（saturation）、亮度（lightness）。CSS3 引入了对应的hsl()属性做为对应的颜色描述方式。 色相是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。以颜色光谱为例，光谱左边从红色开始，移动到中间的绿色，一直到右边的蓝色，色相值就是沿着这条线的取值。在hsl()里面，色相用色环来代替光谱，色相值就是色环里面的颜色对应的从 0 到 360 度的角度值。 饱和度是指色彩的纯度，也就是颜色里灰色的占比，越高色彩越纯，低则逐渐变灰，取0-100%的数值。 亮度决定颜色的明暗程度，也就是颜色里白色或者黑色的占比，100% 亮度是白色， 0% 亮度是黑色，而 50% 亮度是“一般的”。 下面是一些使用hsl()描述颜色的例子，颜色都为满饱和度，中等亮度: 红 hsl(0, 100%, 50%) 黄 hsl(60, 100%, 50%) 绿 hsl(120, 100%, 50%) 蓝绿 hsl(180, 100%, 50%) 蓝 hsl(240, 100%, 50%) 品红 hsl(300, 100%, 50%) 线性渐变(颜色过渡) TML 元素的背景色并不局限于单色。CSS 还提供了颜色过渡，也就是渐变。可以通过background里面的linear-gradient()来实现线性渐变，下面是它的语法： background: linear-gradient(gradient_direction, 颜色 1, 颜色 2, 颜色 3, ...); 第一个参数指定了颜色过渡的方向 - 它的值是角度，90deg 代表垂直渐变，45deg 的渐变角度和反斜杠方向差不多。剩下的参数指定了渐变颜色的顺序： background: linear-gradient(90deg, red, yellow, rgb(204, 204, 255)); 线性渐变条纹元素 repeating-linear-gradient()函数和linear-gradient()很像，主要区别是repeating-linear-gradient()重复指定的渐变。 角度就是渐变的方向。起止渐变颜色值代表渐变颜色及其宽度值，由颜色值和起止位置组成，起止位置用百分比或者像素值表示。 在代码编辑器的例子里，渐变开始于 0 像素位置的yellow，然后过渡到距离开始位置 40 像素的blue。由于下一个起止渐变颜色值的起止位置也是 40 像素，所以颜色直接渐变成第三个颜色值green，然后过渡到距离开始位置 80 像素的red。 下面的代码可以帮助理解成对的起止渐变颜色值是如何过渡的。 0px [黄色 -- 过渡 -- 蓝色] 40px [绿色 -- 过渡 -- 红色] 80px 如果每对起止渐变颜色值的颜色都是相同的，由于是在两个相同的颜色间过渡，那么中间的过渡色也为同色，接着就是同色的过渡色和下一个起止颜色，最终产生的效果就是条纹。 div{ border-radius: 20px; width: 70%; height: 400px; margin: 50 auto; background: repeating-linear-gradient( 45deg, yellow 0px, yellow 40px, black 40px, black 80px ); } 结果: 背景图片 添加一个精致的背景图，可以增加页面的质感，让页面更美观。关键是要找到一个平衡点，抢了内容的风头，喧宾夺主可就不妙了。background属性支持使用url()函数通过链接的方式引入一个指定纹理或样式的图片。图片链接地址在括号内，一般会用引号包起来。 body { background:url(\"https://i.imgur.com/MJAkxbh.png\"); } 创建图形 术语表 属性 功能 属性 功能 blur-radius 模糊半径 spread-radius 辐射半径 transparent 透明的 border-radius 圆角边框 通过使用选择器选择不同的元素并改变其属性，你可以创造一些有趣的形状。比如新月。你可以使用box-shadow属性来设置元素的阴影，border-radius属性控制元素的圆角边框。 .moon{ position: absolute; margin: auto; top: 0; right: 0; bottom: 0; left: 0; width: 100px; height: 100px; background-color: transparent; border-radius: 50%; box-shadow: 25px 10px 0px 0px blue; } 伪类 :hover悬停样式 伪类是可以添加到选择器上的关键字，用来选择元素的指定状态。 如，超链接可以使用:hover伪类选择器定义它的悬停状态样式。下面是悬停超链接时改变超链接颜色的 CSS： a { color: #000; } a:hover { color: blue; } Baidu 知道 :before和:after 用来在选择元素之前和之后添加一些内容 创建心形为例: :before伪类元素用来给 class 为heart的元素添加一个正方形。 .heart:before { content: \"\"; background-color: yellow; border-radius: 25%; position: absolute; height: 50px; width: 70px; top: -50px; left: 5px; } :before和:after必须配合content来使用。这个属性通常用来给元素添加内容诸如图片或者文字。当:before和:after伪类用来添加某些形状而不是图片或文字时，content属性仍然是必需的，但是它的值可以是空字符串。 在上面的例子里，class 为heart元素的:before伪类添加了一个黄色的长方形，长方形的height和width分别为 50px 和 70px。由于设置了其边框半径为 25%，所以长方形为圆角长方形，同时其相对位置为距离left5px，以及向top偏移 50px。 .heart { position: absolute; margin: auto; top: 0; right: 0; bottom: 0; left: 0; background-color: pink; height: 50px; width: 50px; transform: rotate(-45deg);/*用法和skeX,skeY一样,顺时针旋转*/ } .heart:after { background-color: pink; content: \"\"; border-radius: 50%; position: absolute; width: 50px; height: 50px; top: 0px; left: 25px; } .heart:before { content:\"\" ; background-color: pink; border-radius: 50%; position: absolute; width: 50px; height: 50px; top: -25px; left: 0px; } 关键帧和动画 如果要给元素添加动画，需要了解animation属性以及@keyframes规则。animation属性控制动画的外观，@keyframes规则控制动画中各阶段的变化。总共有 8 个animation属性。为了便于理解，本关暂时只涉及到两个最常用的属性。 animation-name设置动画的名称， 也就是要绑定的选择器的@keyframes的名称。 animation-duration设置动画所花费的时间。 @keyframes能够创建动画。 创建动画的原理是将一套 CSS 样式逐渐变化为另一套样式。具体是通过设置动画期间对应的“frames”的 CSS 的属性，以百分比来规定改变的时间，或者通过关键词“from”和“to”，等价于 0% 和 100%。打个比方，CSS 里面的 0% 属性就像是电影里面的开场镜头。CSS 里面的 100% 属性就是元素最后的样子，相当于电影里的演职员表或者鸣谢镜头。CSS 在对应的时间内给元素过渡添加效果。下面举例说明@keyframes和动画属性的用法： #anim { animation-name: colorful; animation-duration: 3s; } @keyframes colorful { 0% { background-color: blue; } 100% { background-color: yellow; } } id 为anim的元素，代码设置animation-name为colorful，设置animation-duration为 3 秒。然后把@keyframes引用到名为colorful的动画属性上。colorful在动画开始时（0%）设置颜色为蓝色，在动画结束时（100%）设置颜色为黄色。注意不是只有开始和结束的过渡可以设置，0% 到 100% 间的任意百分比你都可以设置。 按钮悬停时动画 如果想要的效果是按钮在悬停时始终高亮。这可以通过把animation-fill-mode设置成forwards来实现。animation-fill-mode指定了在动画结束时元素的样式 button { border-radius: 5px; color: white; background-color: #0F5897; padding: 5px 10px 8px 10px; } button:hover { animation-name: background-color; animation-duration: 500ms; animation-fill-mode: forwards;/*悬停时按钮始终高亮*/ } @keyframes background-color { 100% { background-color: #4791d0; } } 注册 动画创建运动 当元素的position被指定，如fixed或者relative时，CSS 偏移属性right、left、top和bottom可以用在动画规则里创建动作。 就像下面的例子展示的那样，你可以在50%keyframe 处设置top属性为 50px， 在开始（0%）和最后（100%）keframe 处设置为 0px，以产生项目向下运动，然后返回的动作效果。 @keyframes rainbow { 0% { background-color: blue; top: 0px; } 50% { background-color: green; top: 50px; } 100% { background-color: yellow; top: 0px; } } 通过淡化元素来创建视觉方向 改变动画元素的opacity，使其在到达屏幕右侧时渐隐。 @keyframes fade { 50% { left: 60%; opacity:0.1; } } 永不停止的动画 还有一个常用的动画属性是animation-iteration-count，这个属性允许你控制动画循环的次数。下面是一个例子： animation-iteration-count: 3; 在这里动画会在运行 3 次后停止，如果想让动画一直运行，可以把值设置成 infinite。 动画定时器 在 CSS 动画里，animation-timing-function规定动画的速度曲线。速度曲线定义动画从一套 CSS 样式变为另一套所用的时间。如果要描述的动画是一辆车在指定时间内（animation-duration）从 A 运动到 B，那么animation-timing-function表述的就是车在运动中的加速和减速等过程。 已经有了很多预定义的值可以直接使用于大部分场景。比如，默认的值是ease，动画以低速开始，然后加快，在结束前变慢。其它常用的值包括ease-out，动画以高速开始，以低速结束;ease-in，动画以低速开始，以高速结束；linear，动画从头到尾的速度是相同的。 .balls { border-radius: 50%; background: linear-gradient( 35deg, #ccffff, #ffcccc ); position: fixed; width: 50px; height: 50px; margin-top: 50px; animation-name: bounce; animation-duration: 2s; animation-iteration-count: infinite; } #ball1 { left:27%; animation-timing-function:linear; } #ball2 { left:56%; animation-timing-function:ease-out; } @keyframes bounce { 0% { top: 0px; } 100% { top: 249px; } } 贝塞尔曲线原理 animation-timing-function除了预定义值之外，CSS 还提供了贝塞尔曲线（Bezier curves）来更出色的控制动画的速度曲线。 在 CSS 动画里，用cubic-bezier来定义贝塞尔曲线。曲线的形状代表了动画的速度。曲线在 1*1 的坐标系统内，曲线的 X 轴代表动画的时间间隔（类似于时间比例尺）(X最大为1)，Y 轴代表动画的改变(Y可以大于1)。 cubic-bezier函数包含了 1 * 1 网格里的4个点：p0、p1、p2和p3。其中p0和p3是固定值，代表曲线的起始点和结束点，坐标值依次为 (0, 0) 和 (1, 1)。你只需设置另外两点的 x 值和 y 值，设置的这两点确定了曲线的形状从而确定了动画的速度曲线。在 CSS 里面通过(x1, y1, x2, y2)来确定p1和p2。综上，下面就是 CSS 贝塞尔曲线的例子： animation-timing-function: cubic-bezier(0.25, 0.25, 0.75, 0.75); 在上面的例子里，两个点的 x 和 y 值相等（x1 = 0.25 = y1 和 x2 = 0.75 = y2），如果你还记得初中几何，结果是从原点到点 (1, 1) 的一条直线。动画速度呈线性，效果和linear一致。换言之，元素匀速运动。 "},"HTML_Introduce/Applied_Accessibility.html":{"url":"HTML_Introduce/Applied_Accessibility.html","title":"Applied Accessibility.md","keywords":"","body":"Applied Accessibility img标签 alt属性中的文本作为备用文字描述了图片的内容，这可以帮助用户在图片加载失败或者不可见的情况下理解图片内容，也有助于搜索引擎理解图片内容，并将其加入到搜索结果中. 良好的alt文本可以简明扼要地描述图片信息，所以你应该为图片添加alt属性。另外，HTML5 标准也在考虑强制要求对图片添加alt属性。(可以将其设置为空,即alt=\"\"或src=\"\") h1-h6表层提层次 页面中的标题标签也应该是有序的，并且能表明内容的层次关系。 标题标签之间以及标签本身都应语义化，不应仅仅为了获得不同字号而使用不同级别的标题标签。 语义化：标签名能准确地表达它所含内容的信息类型。 在使用中，相同级别（或者更高级别）的标题标签用于开启新的章节，低一级别的标题标签用于开启上一级标题标签的子小节。 main元素包裹主题内容 HTML5 添加了诸如main、header、footer、nav、article、section等大量新标签，这些新标签为开发人员提供更多的选择和辅助特性。 默认情况下，浏览器呈现这些新标签的方式与div相似。然而，合理地使用它们，可以使你的标签更加的语义化。辅助技术（如：屏幕阅读器）可以通过这些标签为用户提供更加准确的、易于理解的页面信息。 main标签用于呈现网页的主体内容，且每个页面只能有一个。这意味着它只应包含与页面中心主题相关的信息，而不应包含如导航连接、网页横幅等可以在多个页面中重复出现的内容。 main标签的语义化特性可以使辅助技术快速定位到页面的主体。有些页面中有 “跳转到主要内容” 的链接，使用main标签可以使辅助设备自动获得这个功能。 article元素包裹文章内容 默认情况下，浏览器呈现这些新标签的方式与div相似。然而，合理地使用它们，可以使你的标签更加的语义化。辅助技术（如：屏幕阅读器）可以通过这些标签为用户提供更加准确的、易于理解的页面信息。 main标签用于呈现网页的主体内容，且每个页面只能有一个。这意味着它只应包含与页面中心主题相关的信息，而不应包含如导航连接、网页横幅等可以在多个页面中重复出现的内容。 main标签的语义化特性可以使辅助技术快速定位到页面的主体。有些页面中有 “跳转到主要内容” 的链接，使用main标签可以使辅助设备自动获得这个功能。 请注意section和div的区别： section也是一个 HTML5 新标签，与article标签的语义含义略有不同。article用于独立的、完整的内容，而section用于对与主题相关的内容进行分组。它们可以根据需要嵌套着使用。举个例子：如果一本书是一个article的话，那么每个章节就是section。当内容组之间没有联系时，可以使用div。 - 内容组 - 有联系的内容组 - 独立完整的内容 header元素让屏幕阅读器更易导航 header也是一个具有语义化的、提升页面可访问性的 HTML5 标签。它可以为父级标签呈现简介信息或者导航链接，适用于那些在多个页面顶部重复出现的内容。 与main类似，header的语义化特性也可以使辅助技术快速定位到它的内容。 注意： header用在 HTML 文档的body标签中。这点与包含页面标题、元信息的head标签不同。 nav元素导航 nav也是一个具有语义化特性的 HTML5 标签，用于呈现页面中的主导航链接。它可以使屏幕阅读器快速识别页面中的导航信息。 对于页面底部辅助性质的站点链接，不需要使用nav，用footer 导航A 导航B 导航C 导航A 导航B 导航C footer元素让屏幕阅读器更易导航 与header和nav类似，footer也具有语义化特性，可以使辅助设备快速定位到它。它位于页面底部，用于呈现版权信息或者相关文档链接。 audio 元素提高音频内容可访问 HTML5 的audio标签用于呈现音频内容，它也具有语义化特性。可以在audio上下文中为音频内容添加文字说明或者字幕链接. audio支持controls属性，可以使浏览器为音频提供具有开始、暂停等功能的播放控件。controls属性是一个布尔属性，只要这个属性出现在audio标签中，浏览器就会开启播放控件。 注意： 多媒体内容通常同时包含音频与视频部分，它需要同步音频与字幕，以使视觉或听觉障碍用户可以获取它的内容。一般情况下，网页开发者不需要创建音频与字幕，但是需要将它们添加到多媒体中 figure元素提高图表可访问性 HTML5 引入了figure标签以及与之相关的figcaption标签。它们一起用于展示可视化信息（如：图片、图表）及其标题。这样通过语义化对内容进行分组并配以用于解释figure的文字，可以极大的提升内容的可访问性。 图片下的文字 注意：figcaption包含在figure标签中，并且可以与其他标签组合使用. label元素提高表单可访问性 label标签用于呈现特定表单控件的文本，通常是选项的名称。这些文本代表了选项的含义，使表单具有更好的可读性。label标签的for属性指定了与label绑定的表单控件，并且屏幕阅读器也会读取for属性。 for属性的值必须与表达控件的id属性的值相同。 Name: 单选按钮包裹在 fieldset 元素中 使用fieldset标签将单选按钮组包含在里面就可以实现单选按钮成组出现，用户必须其中选择一项，通常还会使用legend标签来为单选按钮组提供文字说明。 Choose one of these three items: Choice One Choice Two Choice Three Choose one of these three items: Choice One Choice Two Choice Three 日期选择器 表单中经常出现input标签，它可以用来创建多种表单控件。它的type属性指定了所要创建的input标签类型。 在之前已经见过text与submit类型的input标签，HTML5 引入了date类型来创建时间选择器。依赖于浏览器的支持，当点击input标签时，时间选择器会显示出来，这可以让用户填写表单更加容易。 对于旧版本的浏览器，type属性的默认值是text。这种情况下，可以利用label标签或者占位文本来提示用户input标签的输入类型为日期。 Enter a date: HTML5 还引入了time标签与datetime属性来标准化时间。time是一个行内标签，用于在页面中呈现日期或时间，而datetime属性保存了日期的有效格式，辅助设备可以访问这个值。通过标准化时间格式，即使时间在文本中是以非正式的或口语化的形式编写，辅助设备依然可以获取准确的时间和日期。 Master Camper Cat officiated the cage match between Goro and Scorpion last Wednesday, which ended in a draw. 仅对屏幕阅读器可见 如果我们需要在页面中添加一些只对屏幕阅读器可见的内容时，CSS 可以提升页面的可访问性。当信息以可视化形式（如：图表）展示，而屏幕阅读器用户需要一种替代方式（如：表格）来获取信息时，就会出现这种情况。CSS 被用来将这些仅供屏幕阅读器使用的信息定位到浏览器可见区域之外. .sr-only { position: absolute; left: -10000px; width: 1px; height: 1px; top: auto; overflow: hidden; } display: none;或visibility: hidden;会把内容彻底隐藏起来，对于屏幕阅读器也不例外。 如果把值设置为 0px，如width: 0px; height: 0px;，意味着让元素脱离文档流，这样做也会让元素被屏幕阅读器忽略。 高对比度提高文本可读性 低对比度的前景色与背景色会使文本难以阅读。足够的对比度可以提高内容的可读性，但是怎样的对比度才算是 “足够” 的？ Web 内容无障碍指南（WCAG）建议正常文本的对比度至少为 4.5 : 1。对比度是通过比较两种颜色的相对亮度值来计算的，其范围是从相同颜色的 1 : 1（无对比度）到白色与黑色的最高对比度 21 : 1。网上有很多可以帮助你计算对比度的工具。 accesskey 属性快速导航 HTML 提供accesskey属性，用于指定激活标签或者使标签获得焦点的快捷键，这可以使键盘用户的导航更加有效。 HTML5 允许在任何标签上使用这个属性。该属性对于交互类标签（如链接、按钮、表单控件等）十分有用。 Important Button important Button tabindex 添加键盘焦点 HTML 的tabindex属性有三个不同与标签焦点的功能。当它在标签上时，表示标签可以获得焦点。它的值可以是零、负整数及正整数，并决定了标签的行为。 当用户在页面中使用 tab 键时，有些标签，如：链接、表单控件，可以自动获得焦点。它们获得焦点的顺序与它们出现在文档流中的顺序一致。我们可以通过将tabindex属性值设为 0，来给其他标签赋予相同的功能，如：div、span、p等。 tabindex属性还可以指定标签的 tab 键顺序，将它的值设置为大于或等于 1 就可以实现这个功能。 tabindex属性值为 1 的标签将首先获得键盘焦点，然后焦点将按照指定的tabindex的值（如：2，3 等）的顺序进行移动，直到回到默认的或tabindex值为 0 的标签上，如此循环。举个例子： p:focus { background-color: yellow; } I need keyboard focus! 注意： tabindex属性值为负整数（通常为 -1）的标签也是有焦点的，只是不可以通过 tab 键来获得焦点。这种方法通常用于以编程的方式使内容获得焦点（如：激活用于弹出框的div标签, 使用tabindex属性可以使 CSS 伪类:focus在p标签上生效。） Responsive Web Design 创建媒介查询 媒体查询是 CSS3 中引入的一项新技术，它可以根据不同的可视窗口大小显示不同的布局。可视窗口是用户在网页上的可见区域，根据访问网站的设备不同而不同。 媒体查询由媒体类型组成，如果媒体类型与展示网页的设备类型匹配，则应用对应的样式。你可以在媒体查询中用上你想用的选择器和样式。 下面是一个媒体查询的例子，当设备宽度小于或等于 100px 时返回内容： @media (max-width: 100px) { /* CSS Rules */ } 以下定义的媒体查询，是当设备高度大于或等于 350px 时返回内容： @media (min-height: 350px) { /* CSS Rules */ } 只有当媒体类型与当前设备匹配时，才应用媒体查询中的 CSS。 让图片根据设备尺寸自如响应 用 CSS 来让图片自适应其实很简单。不要使用绝对单位： img { width: 720px; } 你应该使用： img { max-width: 100%; display: block; height: auto; } max-width属性能让图片以 100% 的最大宽度适应其父容器的宽度，但图片不会拉伸得比原始宽度还宽。将 display属性设置为 block可以让 image 标签从内联元素（默认值）更改为块级元素。设置 height属性为 auto 保持图片的原始宽高比。 视网膜图片 为优化图片在高分辨率设备下的显示效果，最简单的方式是定义它们的 width和 height值为源文件宽高的一半。 这是一个图片宽高设置为源文件一半的例子： img { height: 250px; width: 250px; } 依设备尺寸排版 除了用 em或 px去设置文本大小, 你还可以用视窗单位来做响应式排版。视窗单位还有百分比，它们都是相对单位，但却基于不同的参照物。视窗单位相对于设备的视窗尺寸 (宽度或高度) ，百分比是相对于父级元素的大小。 四个不同的视窗单位分别是： vw：如 10vw的意思是视窗宽度的 10%。 vh：如 3vh的意思是视窗高度的 3%。 vmin：如 70vmin的意思是视窗中较小尺寸的 70% (高度 VS 宽度)。 vmax：如 100vmax的意思是视窗中较大尺寸的 100% (高度 VS 宽度)。 CSS弹性盒子 display：flex定位两个盒子 只要在一个元素的 CSS 中添加display: flex;，就可以使用其他 flex 属性来构建响应式页面了。 #box-container { height: 500px; display:flex; } #box-1 { background-color: dodgerblue; width: 50%; height: 50%; } #box-2 { background-color: orangered; width: 50%; height: 50%; } flex-direction 属性创建一行 添加了display: flex的元素会成为 flex 容器。只要把flex-direction属性添加到父元素，并设置其为 row 或 column 即可轻易横或竖排列它的子元素。设为 row 可以让子元素水平排列，column 可以让子元素垂直排列。 flex-direction的其他可选值还有 row-reverse 和 column-reverse。 注意： flex-direction的默认值为 row。 justify-content 属性对齐元素 flex 容器里的 flex 子元素有时不能充满整个容器，所以我们需要告诉 CSS 如何以特定方案排列和调整 flex 子元素。幸运的是，我们有justify-content属性处理这个问题。 把 flex 容器设为一个行，它的子元素会从左到右逐个排列，把 flex 容器设为一个列，它的子元素会从上到下逐个排列。子元素排列的方向被称为 main axis（主轴）。对于行，主轴水平贯穿每一个项目；对于列，主轴垂直贯穿每一个项目。 关于 flex 子元素在主轴排列方式，可以选择以下值：其中一个很常用的是justify-content: center;，可以让 flex 子元素排列在 flex 容器中间。其他可选值还有： flex-start：从 flex 容器的前端开始排列项目。对行来说是把项目都靠左放，对于列是把项目都靠顶部放。 flex-end：从 flex 容器的后端开始排列项目。对行来说是把项目都靠右放，对于列是把项目都靠底部放。 space-between：项目间保留一定间距地在主轴排列。第一个和最后一个项目会被挤到容器边沿。例如，在行中第一个项目会紧贴着容器左侧，最后一个项目会紧贴着容器右侧，然后其他项目均匀排布。 space-around：与space-between相似，但头尾两个项目不会紧贴容器边缘，空间会均匀分布在所有项目两边 align-items 属性对齐元素 align-items属性与justify-content类似。 justify-content属性使 flex 子元素沿主轴排列。行的主轴是水平线，列的主轴是垂直线。 Flex 容器中，与主轴垂直的叫做 cross axis（交叉轴）。行的交叉轴是垂直的，列的交叉轴是水平的。 CSS 提供了align-items属性，可以用于在交叉轴调整 flex 子元素。对于行，它规定了项目在容器中应该靠上还是靠下，而对于列，就是靠左或靠右。 align-items的可选值包括： flex-start：从 flex 容器的前端开始排列项目。对行来说是把项目都靠顶部放，对于列是把项目都靠左放。 flex-end：从 flex 容器的后端开始排列项目。对行来说是把项目都靠底部放，对于列是把项目都靠右放。 center：把项目的位置调整到中间。对于行，垂直居中（项目上下方空间相等）。对于列，水平居中（项目左右方空间相等）。 stretch：拉伸项目，填满 flex 容器。例如，排成行的项目从容器顶部拉伸到底部。 baseline：基线对齐地排列。基线是字体相关的概念，可以认为字体坐落在基线上。 flex-wrap 属性包裹 CSS flexbox 有一个把 flex 子元素拆分为多行（或多列）的特性。默认情况下，flex 容器会调整项目大小，把它们都塞到一起。如果是行的话，所有项目都会在一条直线上。 不过，使用flex-wrap属性可以使项目换行。这意味着多出来的项目会被移到新的行或列。换行发生的断点由项目和容器的大小决定。 换行方向的可选值有这些： nowrap：默认值，不换行。 wrap：行从上到下排，列从左到右排。 wrap-reverse：行从下到上排，列从右到左排。 flex-shrink 属性收缩项目 flex-shrink属性使用之后，如果 flex 容器太小，该项目会自动缩小。当容器的宽度小于里面所有项目的宽度，项目就会自动压缩。 flex-shrink属性接受 number 类型的值。数值越大，与其他项目相比会被压缩得更厉害。例如，如果一个项目的flex-shrink为 1 ，另一个项目flex-shrink为 3，那么 3 的那个与另一个相比会受到 3 倍压缩。 flex-grow 属性扩展项目 与flex-shrink相对的是flex-grow。flex-shrink会在容器太小时对元素作出调整。相应地，flex-grow会在容器太大时对元素作出调整。 如果一个项目flex-grow属性的值为 1，另一个flex-grow为 3，那么 3 的会比 1 的扩大三倍。 flex-basis 属性设置初始大小 flex-basis属性指定了项目在 CSS 进行flex-shrink或flex-grow调整前的初始大小。 flex-basis属性的单位与其他 size 属性一致（px、em、%等）。如果值为auto，项目的大小依赖于自身内容。 flex 短方法属性 上面几个 flex 属性有一个简写方式。flex-grow、flex-shrink和flex-basis属性可以在flex中一同设置。 例如，flex: 1 0 10px;会把项目属性设为flex-grow: 1;、flex-shrink: 0;以及flex-basis: 10px;。 属性的默认设置是flex: 0 1 auto;。 #box-container { display: flex; height: 500px; } #box-1 { background-color: dodgerblue; flex:2 2 150px; height: 200px; } #box-2 { background-color: orangered; flex:1 1 150px; height: 200px; } 上面设置的属性，在容器大于 300px 时，会让#box-1填充倍率为#box-2的两倍；在容器小于 300px 时，缩小倍率为#box-2的两倍。300px 是两个盒子的flex-basis的值之和。 order 属性重新排列项目 order属性告诉 CSS flex 容器里项目的顺序。默认情况下，项目排列顺序与源 HTML 文件中顺序相同。这个属性接受数字作为参数，可以使用负数。 align-self 属性 这个属性允许你调整每个项目自己的对齐方式，而不是一次性设置全部项目。因为float、clear和vertical-align等调整使用的属性都不能应用在 flex 子元素，所以这个属性显得十分有用。 align-self的允许值与align-items一样，并且它会覆盖align-items的值。 CSS网格 创建CSS网格 通过将属性display的值设为grid，使 HTML 元素变为网格容器。通过前面的操作，你可以对该容器使用与 CSS 网格（CSS Grid）相关的属性。 注意： 在 CSS 网格中，父元素称为容器（container），它的子元素称为项（items）。 grid-template-columns 添加多列 简单地添加一个网格元素并不能取得很大的进展。你还需要明确网格的结构。在一个网格容器中使用grid-template-columns属性可以添加一些列，示例如下： .container { display: grid; grid-template-columns: 50px 50px; } 上面的代码可以在网格容器中添加两列，宽度均为 50px。 grid-template-columns属性值的个数表示网格的列数，而每个值表示对应列的宽度。 grid-template-rows 添加多行 使用方法同添加多列. 更改网格列和行的大小 在 CSS 网格中，可以使用绝对定位和相对定位单位如px和em来确定行或列的大小。下面的单位也可以使用： fr：设置列或行占剩余空间的一个比例， auto：设置列宽或行高自动等于它的内容的宽度或高度， %：将列或行调整为它的容器宽度或高度的百分比， grid-template-columns: auto 50px 10% 2fr 1fr; grid-column-gap列之间的间距 到目前为止，在你所建立的网格中列都相互紧挨着。如果需要在列与列之间添加一些间隙，我们可以使用grid-column-gap： grid-column-gap: 10px; 这会在我们创建的所有列之间添加 10px 的空白间隙。 同样, 可以用grid-row-gap在两行之间添加间隙。 grid-gap是grid-row-gap和grid-column-gap的简写，它更方便使用。如果grid-gap有一个值，行与行之间和列与列之间将添加等于该值的间隙。但是，如果有两个值，第一个值将作为行间隙的高度值，第二个值是列间隙的宽度值。 grid-gap:10px 20px; grid-column 来控制剩余部分 之前网格的讨论都是围绕网格容器的。grid-column属性是第一个用于网格项本身的属性。 网格的假想水平线和垂直线被称为线（lines）。这些线在网格的左上角从 1 开始编号，垂直线向右、水平线向下累加计数。 这是一个 3x3 网格的线条： 你可以用grid-column属性定义网格项开始和结束的位置，进而控制每个网格项占用的列数。 示例如下： grid-column: 1 / 3; 这会让网格项从左侧第一条线开始到第三条线结束，占用两列。 你可以像列一样使网格项跨越多行。对于一个网格项，你可以用grid-row属性来确定开始和结束的水平线。 对齐项目 justify-self水平对齐 在 CSS 网格中，每个网格项的内容分别位于被称为单元格（cell）的框内。你可以使用网格项的justify-self属性，设置其内容的位置在单元格内沿行轴对齐的方式。默认情况下，这个属性的值是stretch，这将使内容占满整个单元格的宽度。该 CSS 网格属性也可以使用其他的值： start：使内容在单元格左侧对齐， center：使内容在单元格居中对齐， end：使内容在单元格右侧对齐， align-self垂直对齐 值同justify-self一样 justify-items 水平对齐所有项目 align-items 垂直对齐所有项目 网格划分为区域模板 将网格中的一些网格单元格组合成一个区域（area），并为该区域指定一个自定义名称。你可以通过给容器加上grid-template-areas来实现： grid-template-areas: \"header header header\" \"advert content content\" \"footer footer footer\"; 上面的代码将顶部三个单元格合并成一个名为header的区域，将底部三个单元格合并为一个名为footer的区域，并在中间行生成两个区域————advert和content。 注意： 在代码中，每个单词代表一个网格单元格，每对引号代表一行。 除了自定义标签，你还能使用句点（.）来表示一个空单元格 grid-area 属性 在为网格容添加区域模板后，你可以通过添加你定义的名称将网格项放入自定义区域。为此，你需要对网格项使用grid-area： .item1 { grid-area: header; } 这样，类名为item1的网格项就被放到了header区域里。这种情况下，网格项将使用整个顶行，因为这一行被名为 header 区域。 grid-area属性还有另一种使用方式。如果网格中没有定义区域模板，你也可以像这样为它添加一个模板： item1 { grid-area: 1/1/2/4; } grid-area: 起始水平线 / 起始垂直线 / 末尾水平线 / 终止垂直线 ; 因此，示例中的网格项将占用第 1 条和第 2 条水平线之间的行及第 1 条和第 4 条垂直线之间的列。 repeat 函数减少重复 当使用grid-template-columns和grid-template-rows定义网格结构时，你需要为添加的每一行和每一列都输入一个值。 如果要添加带 100 行高度相同的网格，单独放入 100 个值不太实际。幸运的是，有一种更好的方法——使用repeat方法指定行或列的重复次数，后面加上逗号以及需要重复的值。 grid-template-rows: repeat(100, 50px);/*添加 100 行网格的例子，使每行高度均为 50px：*/ grid-template-columns: repeat(2, 1fr 50px) 20px; /*效果等效于*//*==*/ grid-template-columns: 1fr 50px 1fr 50px 20px; minmax 函数限制项目大小 置函数minmax也可以可用于设置grid-template-columns和grid-template-rows的值。它的作用是在网格容器改变大小时限制网格项的大小。为此，你需要指定网格项允许的尺寸范围。例如： grid-template-columns: 100px minmax(50px, 200px); 在上面的代码中，grid-template-columns被设置为添加两列，第一列 100px 宽，第二列宽度最小值是 50px，最大值是 200px auto-fill 创建弹性布局 重复方法带有一个名为自动填充（auto-fill）的功能。它的功能是根据容器的大小，尽可能多地放入指定大小的行或列。你可以通过结合auto-fill和minmax来更灵活地布局。 repeat(auto-fill, minmax(60px, 1fr)); 上面的代码效果：列的宽度会随容器大小改变，在可以插入一个 60px 宽的列之前，当前行的所有列会一直拉伸. 注意： 如果容器无法使所有网格项放在同一行，余下的网格项将移至新的一行。 auto-fit 创建弹性布局 auto-fit效果几乎和auto-fill一样。不同点仅在于，当容器的大小大于各网格项之和时，auto-fill将会持续地在一端放入空行或空列，这样就会使所有网格项挤到另一边；而auto-fit则不会在一端放入空行或空列，而是会将所有网格项拉伸至合适的大小。 注意： 如果容器无法使所有网格项放在同一行，余下的网格项将移至新的一行。 媒体查询创建响应式布局 通过使用媒体查询重新排列网格区域，更改网格尺寸以及重新排列网格项位置，CSS 网格能轻松地使网站更具响应性。 "},"languageLearn/Markdown_Syntax_Summary.html":{"url":"languageLearn/Markdown_Syntax_Summary.html","title":"Markdown Syntax Summary","keywords":"","body":"Markdown Syntax Summary 标题 # //一级标题, 记得#后面有空格 ## //二级标题 ### //三级标题 ......最多六级标题 标题1 标题2 --> 段落 字体 markdown语法 *斜体* _斜体_ **粗体** __粗体__ ***粗斜体*** ___粗斜体___ HTLM语法 粗体 斜体 着重文字 小号字 加重语气 下标字 上标字 插入字 删除字 一段电脑代码 print(\"hello world\") 标记语法高亮 粗体 斜体 着重文字 小号字 加重语气 下标字 上标字 插入字 删除字 一段电脑代码 print(\"hello world\") 标记语法高亮 css渲染 css可以通过以下方式添加到HTML中 内联方式: 在HTML元素中使用style属性 内部样式表: 在HTML文档头部区域使用 元素来包含css 外部引用: 使用外部css文件 内联样式 当特殊样式需要运用到个别元素时,就可以使用内联样式 这是一个段落。 这是一个段落。 style 属性 属性 参数 属性 参数 color red,blue,yellow... margin-left 20px(左空两格) font-family 字体样式... font-size 字体大小定义(单位px)... text-align center,left,right background-color red,green,blue... 内部样式表 当单个文件需要特别样式时,可以使用内部样式表,你可以在部分通过标签定义内部样式表 body {background-color:yellow;} p {color:blue;} 外部样式表 当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。 线 分割线 在一行中用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西，也可以三个符合中间插入空格，都能建立分割线。 *** ___ --- 删除线 只需在文字两端加上两个~~号就可以了 ~~删除线~~ 下划线 下划线可以通过HTLM的标签来实现 下划线文本 下划线文本 脚注 脚注是对文本的补充说明. [^要注明的文本] example [^Markdown]是一种语法. [^Markdown]:文本编辑语言 Markdown是一种语法. 列表 无序列表 使用星号(*), 加号(+), 减号(-). 作为列表标记, 这些标记后面要添加一个空格,然后填写内容. * 第一项 * 第二项 * 第三项 有序列表 使用数字加上(.)作为列表标记,后面跟空格和填写内容. 1. 第一项 2. 第二项 3. 第三项 自定义列表 Coffee - black hot drink Milk - white cold drink Coffee - black hot drink Milk - white cold drink 列表嵌套 只需要在子列表中的选项前面加四个空格即可. 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 引用和代码 引用 段落开头使用>符号, 后面跟一个空格加上内容即可. > 这里是引用的内容 引用中的嵌套 > 引用内容 >> 第二层引用 代码 如果只是一句话的某个代码片段可以用（`）包起来 `print` `int` 用```来包裹一段代码(也可以指名是哪种语言) ```java public class Demo{ public static void main(String[] args){ System.out.println(\"Hello,World!\"); } } ​ public class Demo{ public static void main(String[] args){ System.out.println(\"Hello,World!\"); } } ## 链接 链接使用方法如下: ```markdown [链接名称](链接地址) 或者 example: [baidu](www.baidu.com) 链接方法二: 可以通过一个变量来设置一个链接，变量赋值在文档末尾进行. 这个1作为一个网址变量[baidu][1] [1]:www.baidu.com HTML链接 链接标签 Baidu 跳转 页内跳转 使用markdown语法, 跳转到标题所在位置. [任意文字] (#标题名称) 使用HTML语法,可以跳转到页面内任意位置 点击跳转到anchor [点击跳转到anchor](#anchor) 图片 markdown语法格式如下: ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 \"可选标题\") 开头一个感叹号! 接着一个方括号, 里面放图片代替的文字 接着一个普通括号,里面放上图片的地址,最后还可以用引号包住并加上选择性的标题属性文字. markdown没有办法指定图片的高度,宽度,和位置,可以使用标签 表格 markdown表格 表格语法 |表头1|表头2|表头3| |------| :- -: |------:| |左对齐|居中对齐|右对齐| HTML表格 序号 维修项目及更换配件 单价 数量 小计 工时费 合计 故障原因 1 2 3 4 5 6 7 备件费用小计： 工时费用小计： 合计： HTML表格标签 标签 描述 标签 描述 table 定义表格 th 定义表格的表头 tr 定义表格的行 td 定义表格的单元 caption 定义表格标题 colgroup 定义表格列的组 col 定义表格列的属性 thead 定义表格页眉 tbody 定义表格主体 tfoot 定义表格页脚 rowspan=\"\" 跨行单元格定义 colspan=\"\" 跨列单元格定义 markdown高级技巧 支持HTML元素 不在markdown涵盖范围内的标签,可以直接在文档里面用HTLM撰写. example: 使用Ctrl+Alt+del重启电脑 使用Ctrl+Alt+del重启电脑 转义 **粗体** \\*\\*粗体\\*\\* **粗体** 数学公式 当需要在编辑器中插入数学公式时,可以使用$$包裹TeX或LaTeX格式的数学公式来实现 $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\\\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\\\ \\end{vmatrix} ${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}} $$ $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\ \\end{vmatrix} ${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}} $$ 数学公式表达详见 流程图 横向流程图源码格式 ```mermaid graph LR A[方形] -->B(圆角) B --> C{条件A} C --> |a=1| D[结果1] C --> |a=2| E[结果2] F(横向流程图) ​ ```mermaid graph LR A[方形] -->B(圆角) B --> C{条件A} C --> |a=1| D[结果1] C --> |a=2| E[结果2] F(横向流程图) 竖向流程图源码格式 ```mermaid graph LR A[方形] -->B(圆角) B --> C{条件A} C --> |a=1| D[结果1] C --> |a=2| E[结果2] F(横向流程图) ​ ```mermaid graph TD A[方形] -->B(圆角) B --> C{条件A} C --> |a=1| D[结果1] C --> |a=2| E[结果2] F(横向流程图) 标准流程图源码格式 ```flow st=>start: 开始框 op=>operation: 处理框 cond=>condition: 判断框 sub=>subroutine: 子流程 io=>inputoutput: 输入输出框 e=>end: 结束框 st->op->cond cond(yes)->io->e cond(no)->sub(right)->op ​ ```flow st=>start: 开始框 op=>operation: 处理框 cond=>condition: 判断框 sub=>subroutine: 子流程 io=>inputoutput: 输入输出框 e=>end: 结束框 st->op->cond cond(yes)->io->e cond(no)->sub(right)->op 标准流程图源码格式横向 ```flow st=>start: 开始框 op=>operation: 处理框 cond=>condition: 判断框 sub=>subroutine: 子流程 io=>inputoutput: 输入输出框 e=>end: 结束框 st(right)->op(right)->cond cond(yes)->io(bottom)->e cond(no)->sub(right)->op ​ ```flow st=>start: 开始框 op=>operation: 处理框 cond=>condition: 判断框 sub=>subroutine: 子流程 io=>inputoutput: 输入输出框 e=>end: 结束框 st(right)->op(right)->cond cond(yes)->io(bottom)->e cond(no)->sub(right)->op UML时序图源码样式 ```sequence 对象A->对象B:对象B还好吗?(请求) Note right of 对象B:对象B的描述 Note left of 对象A:对象A的描述 对象B->对象A:我很好(响应) 对象A->对象B:嗯 ​ ```sequence 对象A->对象B:对象B还好吗?(请求) Note right of 对象B:对象B的描述 Note left of 对象A:对象A的描述 对象B->对象A:我很好(响应) 对象A->对象B:嗯 UML时序图源码复杂样例 ```sequence Title: 标题：复杂使用 对象A->对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B-->对象A: 我很好(响应) 对象B->小三: 你好吗 小三-->>对象A: 对象B找我了 对象A->对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 ​ ```sequence Title: 标题：复杂使用 对象A->对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B-->对象A: 我很好(响应) 对象B->小三: 你好吗 小三-->>对象A: 对象B找我了 对象A->对象B: 你真的好吗？ Note over 小三,对象B: 我们是朋友 participant C Note right of C: 没人陪我玩 UML标准时序图样例 ```mermaid %% 时序图例子,-> 直线，-->虚线，->>实线箭头 sequenceDiagram participant 张三 participant 李四 张三->王五: 王五你好吗？ loop 健康检查 王五->王五: 与疾病战斗 end Note right of 王五: 合理 食物 看医生... 李四-->>张三: 很好! 王五->李四: 你怎么样? 李四-->王五: 很好! ​ ```mermaid %% 时序图例子,-> 直线，-->虚线，->>实线箭头 sequenceDiagram participant 张三 participant 李四 张三->王五: 王五你好吗？ loop 健康检查 王五->王五: 与疾病战斗 end Note right of 王五: 合理 食物 看医生... 李四-->>张三: 很好! 王五->李四: 你怎么样? 李四-->王五: 很好! 甘特图案例 ```mermaid %% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h ​ ```mermaid %% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h markdown 语法基础 "},"languageLearn/JavaScript_basic_learning.html":{"url":"languageLearn/JavaScript_basic_learning.html","title":"JavaScript basic learning","keywords":"","body":"javascript basic learning 注释 被注释的代码块在 JavaScript 之中是不会执行的。在代码中写注释是一个非常好的方式让你自己和其他人理解代码。 JavaScript 中的注释方式有以下两种： // 单行注释 /* ------------*/ 多行注释 变量声明 JavaScript 提供七种不同的数据类型，如下: 数据类型 名词解释 数据类型 名词解释 数据类型 名词解释 undefined 未定义 null 空 boolean 布尔型 string 字符串 symbol 符号 number 数字 object 对象 变量允许计算机以一种动态的形式来存储和操作数据，通过操作指向数据的指针而不是数据本身来避免了内存泄露，以上的七种数据类型都可以存储到一个变量中。 变量非常类似于你在数学中使用的 x，y 变量，都是以一个简单命名的名称来代替我们赋值给它的数据。计算机中的变量与数学中的变量不同的是，计算机可以在不同的时间存储不同类型的变量。 通过在变量的前面使用关键字var，声明一个变量，例如： var yourname; 上面代码的意思是创建一个名为yourname的变量，在 JavaScript 中我们以分号结束语句。 变量名称可以由数字、字母、美元符号$或者 下划线_组成，但是不能包含空格或者以数字为开头。 赋值运算符存储值 在 JavaScript 中，你可以使用赋值运算符将值存储在变量中。 myVariable = 5; 这条语句把Number类型的值5赋给变量myVariable。 赋值过程是从右到左进行的。在将值分配给运算符左侧的变量之前，将解析=运算符右侧的所有内容。 通常在声明变量的时候会给变量初始化一个初始值。 var myVar = 0; 当 JavaScript 中的变量被声明的时候，程序内部会给它一个初始值undefined。当你对一个值为undefined的变量进行运算操作的时候，算出来的结果将会是NaN，NaN的意思是\"Not a Number\"。当你用一个值是undefined的变量来做字符串拼接操作的时候，它会输出字符串\"undefined\"。 驼峰命名法:Javascript 变量一般使用驼峰命名法，变量名的第一个单词的首写字母小写，后面的单词的第一个字母大写,如var anotherVariableName;。 运算 示例 var myVar = 5 + 10; // 赋值为 15 var myVar = 12 - 6; // 赋值为 6 var myVar = 13 * 13; // 赋值为169 var myVar = 16 / 2; // 赋值为8 var i++; //对变量i+1运算 /*等效于*/ var i = i + 1; var i--; //对变量i-1运算 /*等效于*/ var i = i - 1; var myRemainder =5 % 2 ; //f赋值为1, 求余运算 复合运算 在编程当中，通常通过赋值来修改变量的内容。记住，赋值时 Javascript 会先计算=右边的内容，所以我们可以写这样的语句： myVar = myVar + 5; 以上是最常见的运算赋值语句，即先运算、再赋值。还有一类操作符是一步到位既做运算也赋值的。 其中一种就是+=运算符。 var myVar = 1; myVar += 5; console.log(myVar); // 返回 6 /* 同理*/ myVar = myVar - 5; /*等于*/ myVar -=5; myVar = myVar * 5; /*等于*/ myVar *=5; myVar = myVar / 5; /*等于*/ myVar /=5; myVar = myVar % 5; /*等于*/ myVar %=5; 转义字符串的引号 转义一个字符串必须要用单引号或双引号来包裹它。那么当你的字符串里面包含：\"或者'时该怎么办呢? 在 JavaScript 中，你可以通过在引号前面使用反斜杠（\\）来转义引号。 var sampleStr = \"Alan said, \\\"Peter is learning JavaScript\\\".\"; 有了转义符号，JavaScript 就知道这个单引号或双引号并不是字符串的结尾，而是字符串内的字符。所以，上面的字符串打印到控制台的结果为： Alan said, \"Peter is learning JavaScript\". 转义序列 代码 序列 代码 序列 代码 序列 \\' 单引号 \\\" 双引号 \\\\ 反斜杠 \\n 换行符 \\r 回车符 \\t 制表符 \\b 退格 \\f 换页符 ||||||||||||||||||||||||||| myStr=\"FirstLine\\n\\t\\\\\\SecondLine\\nThirdLine\" /*result:*/ FirstLine \\SecondLine ThirdLine 查找字符串长度 你可以通过在字符串变量或字符串后面写上.length来获得字符串变量字符串值的长度。 \"Alan Peter\".length; // 10 使用方括号查找字符串中的第一个字符 方括号表示法是一种在字符串中的特定index（索引）处获取字符的方法。 例如, 在单词 \"Charles\" 中索引 0 上的字符为 \"C\"，所以在var firstName = \"Charles\"中，你可以使用firstName[0]来获得第一个位置上的字符。 你也可以使用方括号来获得一个字符串中的其他位置的字符。 字符串的不变性 在 JavaScript 中，字符串的值是 不可变的，这意味着一旦字符串被创建就不能被改变。 例如，下面的代码： var myStr = \"Bob\"; myStr[0] = \"J\"; 是不会把变量myStr的值改变成 \"Job\" 的，因为变量myStr是不可变的。注意，这并不意味着myStr永远不能被改变，只是字符串字面量 string literal 的各个字符不能被改变。改变myStr中的唯一方法是重新给它赋一个值，例如： var myStr = \"Bob\"; myStr = \"Job\"; 数组 使用数组，我们可以在一个地方存储多个数据。 一维数组 以左方括号[开始定义一个数组，以右方括号]结束，里面每个元素之间用逗号隔开，例如： var sandwich = [\"peanut butter\", \"jelly\", \"bread\",100]. 多维数组 你也可以在数组中包含其他数组，例如：[[\"Bulls\", 23], [\"White Sox\", 45]]。 数组索引 我们可以像操作字符串一样通过数组索引[index]来访问数组中的数据。 数组索引的使用与字符串索引一样，不同的是，通过字符串的索引得到的是一个字符，通过数组索引得到的是一个元素。与字符串类似，数组也是基于零的索引，因此数组的第一个元素的索引是0。 var array = [50,60,70]; array[0]; // 值为 50 var data = array[1]; // 值为 60 提示: 数组名称和方括号之间不应有任何空格，如array [0]尽管 JavaScript 能够正确处理，但可能会让看你代码的其他程序员感到困惑 修改数组数据 与字符串的数据不可变不同，数组的数据是可变的，并且可以自由地改变。 var ourArray = [50,40,30]; ourArray[0] = 15; // 等于 [15,40,30] 索引多维数组 可以把 多维 数组看作成是一个 数组中的数组。当使用方括号去访问数组的时候，第一个[index]访问的是第 N 个子数组，第二个[index]访问的是第 N 个子数组的第N个元素。 var arr = [ [1,2,3], [4,5,6], [7,8,9], [[10,11,12], 13, 14] ]; arr[3]; // 等于 [[10,11,12], 13, 14] arr[3][0]; // 等于 [10,11,12] arr[3][0][1]; // 等于 11 push()操作数组 一个简单的方法将数据添加到一个数组的末尾是通过push()函数。 .push()接受把一个或多个参数，并把它“推”入到数组的末尾。 var arr = [1,2,3]; arr.push(4); // 现在arr的值为 [1,2,3,4] pop()操作数组 改变数组中数据的另一种方法是用.pop()函数。 .pop()函数用来“抛出”一个数组末尾的值。我们可以把这个“抛出”的值赋给一个变量存储起来。换句话说就是.pop()函数移除数组末尾的元素并返回这个元素。 数组中任何类型的元素（数值，字符串，甚至是数组）可以被“抛出来” 。 var threeArr = [1, 4, 6]; var oneDown = threeArr.pop(); console.log(oneDown); // 输出 6 console.log(threeArr); // 输出 [1, 4] shift()操作数组 .shift()的工作原理就像.pop()，但它移除的是第一个元素，而不是最后一个。 unshift()操作数组 你不仅可以shift（移出）数组中的第一个元素，你也可以unshift（移入）一个元素到数组的头部。 .unshift()函数用起来就像.push()函数一样, 但不是在数组的末尾添加元素，而是在数组的头部添加元素。 函数编写可重用代码 在 JavaScript 中，我们可以把代码的重复部分抽取出来，放到一个函数中。 举个例子： function functionName() { console.log(\"Hello World\"); } /*你可以通过函数名`functionName`加上后面的小括号来调用这个函数，就像这样：*/ functionName(); 每次调用函数时，它都会在控制台上打印消息\"Hello World\"。每次调用函数时，大括号之间的所有代码都将被执行。 全局作用域和函数 在 JavaScript 中，作用域涉及到变量的作用范围。在函数外定义的变量具有 全局 作用域。这意味着，具有全局作用域的变量可以在代码的任何地方被调用。 这些没有使用var关键字定义的变量，会被自动创建在全局作用域中，形成全局变量。当在代码其他地方无意间定义了一个变量，刚好变量名与全局变量相同，这时会产生意想不到的后果。因此你应该总是使用var关键字来声明你的变量。 局部作用域和函数 在一个函数内声明的变量，以及该函数的参数都是局部变量，意味着它们只在该函数内可见。 这是在函数myTest内声明局部变量loc的例子： function myTest() { var loc = \"foo\"; console.log(loc); } myTest(); // 打印出 \"foo\" console.log(loc); // loc 没有定义 "},"languageLearn/java_Learning.html":{"url":"languageLearn/java_Learning.html","title":"java Learning","keywords":"","body":"java Learning 包机制 为了更好的组织类，java提供了包机制，用于区别类名的命名空间。 包语句的语法格式： package pkg1[. pkg2[. pkg3...]]; 包的本质就是一个文件夹 一般利用公式域名倒置建立包名, 为了能够使用某一个包的成员,我们需要在java程序中明确导入该包. 使用\"import\"语句可完成此功能. import package1[.package2...].(classname|*); Scanner 对象 java.util.Scanner是java5的新特性,我们可以通过Scanner类来获取用户的输入. 基本语法: Scanner s = new Scanner(System.in); 通过Scanner类的next()与nextLine()方法获取输入的字符串,在读取前我们一般需要使用hasNext()与hasNextLine()判断是否还有输入数据. next() 一定要读取到有效字符后才可以结束输入; 对输入的有效字符之前遇到的空白,next()方法会自动将其去掉; 只有输入有效字符后才将其后边输入的空白作为分隔符或者结束符; next()不能得到带有空格的字符串; nextLine() 以enter为结束符,也就是说 nextLine()方法返回的是输入回车之前所有字符; 可以获得空白; "},"languageLearn/python_basic.html":{"url":"languageLearn/python_basic.html","title":"python basic","keywords":"","body":"python 入门 method #List x1=[1,2,3,4,5,6,7,8,9] #tuple x2=(1,2,3,4,5,6,7,8,9) #string x3=\"123456789\" 求长度len(): len(x1), len(x2), len(x3) 求最小min():min(x1), min(x2), min(x3) 求最大max():max(x1), max(x2), max(x3) 求和sum():sum(x1), sum(x2) 增加元素append(),追加在数组后面 : x1.append(\"3\") 增加多个元素extend(),追加在数组后面 : x1.extend([22,48]) 插入元素insert(position,element) : x1.insert(2,55) 删除元素pop(index(optional)),index可选,默认是最后一个,并且把这个元素返回回来 : x1.pop(2) 删除元素remove(element),根据元素内容删除数组查找的第一个元素,并且没有返回值 : x1.remove(7) 关键字del: del x1[index] 查找元素index(element), 查找元素在列表中的索引位置,返回位置 : x1.index(7) 反转队列reverse(), 反转对象是修改原来的队列,没有返回值 : x1.reverse() 反转队列x1[::-1], 有返回值 : x1[::-1] 统计某个元素在列表中出现的次数count(element),: x1.count(20) "},"languageLearn/ADB_command.html":{"url":"languageLearn/ADB_command.html","title":"ADB command","keywords":"","body":"ADB 命令 adb shell 进入UE cat /proc/cpuinfo 打印cpu信息 df -h 获取UE真实的存储空间 wm size 获取UE的分辨率 cat /system/bulid.prop 设备信息(修改?) getprop ro.bulid.version.release 系统版本 "},"languageLearn/vimrc.html":{"url":"languageLearn/vimrc.html","title":"vimrc","keywords":"","body":"Linux 配置 vim美化 vim文件配置 在cd $user目录下, 创建一个.vim文件. cd .vim目录下,创建一个vimrc文本. 将下面内容拷贝到vimrc文本中. colorscheme molokai \" 设置主题 setlocal list filetype indent on \" 检测文件类型,并且载入与该类型对应的缩进规则 map :NERDTreeToggle \" hi SpecialKey guifg=darkgrey ctermfg=darkgrey autocmd BufWritePost $MYVIMRC source $MYVIMRC \" 让vimrc配置立即生效 map :set mouse=ni map :set mouse=v set nocompatible \" 去vi的一致性 set number \" 显示行号 set guioptions-=r \" 隐藏编辑器右侧滚动条 set guioptions-=L \" 如果窗口垂直分隔，隐藏编辑器左侧滚动条 set guioptions-=b \" 隐藏编辑器底部滚动条 set guioptions =a \" 在可视化模式下选中文本,Vim会将所选文本放置到系统的全局寄存器中 set showtabline=0 \" 隐藏顶部标签栏 set guifont=Fira \" 设置字体 set showmode \" 在底部显示当前处于命令模式还是插入模式 set encoding=utf-8 \" 使用utf-8编码 set t_Co=256 \" 256色域 set background=dark \" 设置背景色 set wrap \" 设置折行 set autoindent \" 自动对齐 set smartindent \" 智能选择对 set fileformat=unix \" 设置以unix的格式保存文件 set tabstop=2 \" 设置table长度 set shiftwidth=4 \" 设置当行之间交错时使用4个空格 set expandtab \" 自动将tab转换为空格 set softtabstop=2 \" tab转换为多少个空格 set textwidth=80 \" 设置行宽，即一行显示多少个字符 set showmatch \" 显示匹配的括号 set scrolloff=5 \" 距离顶部和底部5行 set ruler \" 在状态栏显示光标的当前位置（位于哪一行哪一列） set laststatus=2 \" 是否显示状态栏。0 表示不显示，1 表示只在多窗口时显示，2 表示显示。 set backspace=eol,start,indent \" 退格键 set mouse=ni \" 启用鼠标 set selection=exclusive set selectmode=mouse,key set matchtime=2 \" 短暂跳转到匹配括号的时间 set ignorecase \" 搜索时忽略大小写 set incsearch \" 输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果。 set hlsearch \" 高亮搜索项 \" set spell spelllang=en_us,cjk \" 打开英语拼写检查 set nobackup \" 不创建备份文件 set noswapfile \" 不创建交换文件 set noerrorbells \" 出错时，不要发出响声 \"set visualbell \" 出错时，发出视觉提示，通常是屏幕闪烁 \"set autoread \" 打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示 set wildmenu \" 启用增强模式的命令行补全 set wildmode=longest:list,full \" 命令模式下，底部操作指令按下 Tab 键自动补全。 set whichwrap+=,h,l set cursorline \" 突出显示当前行 set cursorcolumn \" 突出显示当前列 \" set clipboard=unnamedplus \" 共享剪切板 set pastetoggle= set helplang=cn \" 帮助中文支持 set listchars=tab:--,trail:- \" tab和空格转换 set completeopt=preview,menu set completeopt=longest,menu call plug#begin('~/.vim/plugged') Plug 'valloric/youcompleteme' Plug 'itchyny/lightline.vim' Plug 'Yggdroot/indentLine' Plug 'preservim/nerdtree' Plug 'Yggdroot/LeaderF', { 'do': './install.sh' } Plug 'jiangmiao/auto-pairs' Plug 'preservim/nerdcommenter' Plug 'vim-airline/vim-airline' Plug 'vim-airline/vim-airline-themes' Plug 'godlygeek/tabular' Plug 'hdima/python-syntax' Plug 'justinmk/vim-syntax-extra' Plug 'octol/vim-cpp-enhanced-highlight' Plug 'luochen1990/rainbow' Plug 'sillybun/vim-repl' call plug#end() \" godlygeek/tabular 代码对齐 :Tab/: \" python_syntax let python_highlight_all = 1 \" indentLine configure let g:indentLine_noConcealCursor = 1 let g:indentLine_color_term = 0 let g:indentLine_char = '|' \"nerdcommenter configure let g:NERDSpaceDelims = 1 let g:NERDCompactSexyComs = 1 let g:NERDDefaultAlign = 'left' let g:NERDAltDelims_java = 1 let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } } let g:NERDCommentEmptyLines = 1 let g:NERDTrimTrailingWhitespace = 1 let g:NERDToggleCheckAllLines = 1 \"YouCompleteMe Configure let g:ycm_global_ycm_extra_conf = '~/.vim/plugged/youcompleteme/third_party/ycmd/.ycm_extra_conf.py' let g:ycm_confirm_extra_conf = 0 let g:ycm_seed_identifiers_with_syntax = 1 let g:ycm_complete_in_comments = 1 let g:ycm_collect_identifiers_from_comments_and_strings = 0 let g:ycm_complete_in_strings = 1 let g:ycm_collect_identifiers_from_tags_files = 1 let g:ycm_collect_identifiers_from_tags_files = 1 let g:ycm_min_num_of_chars_for_completion = 2 let g:ycm_autoclose_preview_window_after_completion = 1 let g:ycm_cache_omnifunc=0 \" let g:ycm_add_preview_to_completeopt = 0 \" let g:ycm_show_diagnostics_ui = 0 \" let g:ycm_server_log_level = 'info' \" let g:ycm_min_num_identifier_candidate_chars = 2 \" let g:ycm_collect_identifiers_from_comments_and_strings = 1 \" let g:ycm_complete_in_strings=1 let g:ycm_semantic_triggers = { \\ 'c,cpp,python,java,go,erlang,perl': ['re!\\w{2}'], \\ 'cs,lua,javascript': ['re!\\w{2}'], \\ } autocmd InsertLeave * if pumvisible() == 0|pclose|endif let g:ycm_seed_identifiers_with_syntax = 1 let g:ycm_use_ultisnips_completer = 1 let g:ycm_goto_buffer_command = 'horizontal-split' nnoremap g :YcmCompleter GoTo \" rainbow configure let g:rainbow_active = 1 \"0 if you want to enable it later via :RainbowToggle let g:rainbow_conf = { \\ 'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick'], \\ 'ctermfgs': ['lightblue', 'lightyellow', 'lightcyan', 'lightmagenta'], \\ 'operators': '_,_', \\ 'parentheses': ['start=/(/ end=/)/ fold', 'start=/\\[/ end=/\\]/ fold', 'start=/{/ end=/}/ fold'], \\ 'separately': { \\ '*': {}, \\ 'tex': { \\ 'parentheses': ['start=/(/ end=/)/', 'start=/\\[/ end=/\\]/'], \\ }, \\ 'lisp': { \\ 'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick', 'darkorchid3'], \\ }, \\ 'vim': { \\ 'parentheses': ['start=/(/ end=/)/', 'start=/\\[/ end=/\\]/', 'start=/{/ end=/}/ fold', 'start=/(/ end=/)/ containedin=vimFuncBody', 'start=/\\[/ end=/\\]/ containedin=vimFuncBody', 'start=/{/ end=/}/ fold containedin=vimFuncBody'], \\ }, \\ 'html': { \\ 'parentheses': ['start=/\\v\\])@!\\z([-_:a-zA-Z0-9]+)(\\s+[-_:a-zA-Z0-9]+(\\=(\"[^\"]*\"|'.\"'\".'[^'.\"'\".']*'.\"'\".'|[^ '.\"'\".'\">/ end=## fold'], \\ }, \\ 'css': 0, \\ } \\} \" 支持在Visual模式下，通过C-y复制到系统剪切板 vnoremap \"+y \" 支持在normal模式下，通过C-p粘贴系统剪切板 nnoremap \"*p \" airline configure \" 设置状态栏 let g:airline#extensions#tabline#enabled = 1 let g:airline#extensions#tabline#left_sep = ' ' let g:airline#extensions#tabline#left_alt_sep = '|' \" Show just the filename let g:airline#extensions#tabline#fnamemod = ':t' let g:airline#extensions#tabline#formatter = 'default' let g:airline#extensions#tabline#buffer_nr_show = 1 \" 映射切换buffer的键位 nnoremap [b :bp nnoremap ]b :bn let g:airline_theme ='luna' \" 主题 let g:airline_powerline_fonts = 1 \"vim repl let g:repl_program = { \\ 'python': 'ipython3', \\ 'default': 'bash', \\ 'r': 'R', \\ 'lua': 'lua', \\ } let g:repl_predefine_python = { \\ 'numpy': 'import numpy as np', \\ 'matplotlib': 'from matplotlib import pyplot as plt' \\ } let g:repl_cursor_down = 1 let g:repl_python_automerge = 1 let g:repl_ipython_version = '7.13' let g:repl_position = 3 \" let g:repl_width = None \"窗口宽度 \" let g:repl_height = None \"窗口高度 let g:sendtorepl_invoke_key = \"w\" \"传送代码快捷键，默认为w let g:repl_position = 0 \"0表示出现在下方，1表示出现在上方，2在左边，3在右边 let g:repl_stayatrepl_when_open = 0 \"打开REPL时是回到原文件（1）还是停留在REPL窗口中（0） nnoremap r :REPLToggle autocmd Filetype python nnoremapk :REPLDebugStopAtCurrentLine autocmd Filetype python nnoremap l :REPLPDBN autocmd Filetype python nnoremap m :REPLPDBS \" windows copy map : call CopyToWindows() map! : call CopyToWindows() func! CopyToWindows() exec \"w\" exec \"!cat % |/mnt/c/Windows/System32/clip.exe\" endfunc autocmd BufNewFile *.py exec \":call SetPythonTitle()\" func SetPythonTitle() call append(0,\"######################################################\") call append(1,\"# File Name: \".expand(\"%\")) call append(2,\"# Author: Yuling You\") call append(3,\"# Mail: yuling.youe@gmail.com\") call append(4,\"# Created Time: \".strftime(\"%Y-%m-%d\",localtime())) call append(5,\"# Version: \") call append(6,\"# Description: \") call append(7,\"#\") call append(8,\"#####################################################\") call append(9,\"#! /usr/bin/env python3\") call append(10,\"#-*- coding: utf-8 -*-\") endfunc autocmd BufNewFile * normal G map rr :call CompileRunGcc() func! CompileRunGcc() exec \"w\" if &filetype == 'c' silent exec \"!g++ % -o % %.html &\" exec \"!firefox %.html &\" endif endfunc vim molokai主题下载 进入.vim文件, 在目录下创建colors文件. 克隆molokai文件: git clone https://github.com/tomasr/molokai.git 将克隆下来的molokai 文件里面的molokai.vim移动到colors文件中. cd molokai/colors mv molokai.vim ~/.vim/colors vim 升级 8.2 添加 Vim 的 PPA sudo add-apt-repository ppa:jonathonf/vim 开始安装 sudo apt-get update sudo apt-get install -y vim-gtk3 执行 vim.gtk3 --version 命令得到： VIM - Vi IMproved 8.2 (2019 Dec 12, compiled Jun 21 2020 13:13:53) Included patches: 1-1027 ... Cmake 升级 卸载当前旧版本的cmake 查看当前的cmake版本：cmake --version 若版本较旧，执行：sudo apt remove cmake，卸载旧版的cmake 若当前系统无cmake，可跳过这一步。 安装依赖 sudo apt install build-essential libssl-dev 下载并编译源码 cmake官方下载地址为：https://cmake.org/download/（我下载的是3.17.0） 执行以下命令解压： sudo tar xf cmake-3.17.0.tar.gz （这里可直接解压到/usr/local里，这样后面生成的可执行文件会在/usr/local/bin里创建链接） 环境检查、编译和安装 cd进入解压出来的文件夹，执行： sudo ./configure sudo make sudo make install 创建软链接 sudo ln -sf /usr/local/bin/* /usr/bin/ 再执行：cmake -version 如果出现版本号就代表安装成功。 .bashrc 文件 # ~/.bashrc: executed by bash(1) for non-login shells. # see /usr/share/doc/bash/examples/startup-files (in the package bash-doc) # for examples # If not running interactively, don't do anything case $- in *i*) ;; *) return;; esac # don't put duplicate lines or lines starting with space in the history. # See bash(1) for more options HISTCONTROL=ignoreboth # append to the history file, don't overwrite it shopt -s histappend # for setting history length see HISTSIZE and HISTFILESIZE in bash(1) HISTSIZE=1000 HISTFILESIZE=2000 # check the window size after each command and, if necessary, # update the values of LINES and COLUMNS. shopt -s checkwinsize # If set, the pattern \"**\" used in a pathname expansion context will # match all files and zero or more directories and subdirectories. #shopt -s globstar # make less more friendly for non-text input files, see lesspipe(1) [ -x /usr/bin/lesspipe ] && eval \"$(SHELL=/bin/sh lesspipe)\" # set variable identifying the chroot you work in (used in the prompt below) if [ -z \"${debian_chroot:-}\" ] && [ -r /etc/debian_chroot ]; then debian_chroot=$(cat /etc/debian_chroot) fi # set a fancy prompt (non-color, unless we know we \"want\" color) case \"$TERM\" in xterm-color|*-256color) color_prompt=yes;; esac # uncomment for a colored prompt, if the terminal has the capability; turned # off by default to not distract the user: the focus in a terminal window # should be on the output of commands, not on the prompt #force_color_prompt=yes if [ -n \"$force_color_prompt\" ]; then if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then # We have color support; assume it's compliant with Ecma-48 # (ISO/IEC-6429). (Lack of such support is extremely rare, and such # a case would tend to support setf rather than setaf.) color_prompt=yes else color_prompt= fi fi if [ \"$color_prompt\" = yes ]; then PS1='${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' else PS1='${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' fi unset color_prompt force_color_prompt # If this is an xterm set the title to user@host:dir case \"$TERM\" in xterm*|rxvt*) PS1=\"\\[\\e]0;${debian_chroot:+($debian_chroot)}\\u@\\h: \\w\\a\\]$PS1\" ;; *) ;; esac # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors && eval \"$(dircolors -b ~/.dircolors)\" || eval \"$(dircolors -b)\" alias ls='ls --color=auto' #alias dir='dir --color=auto' #alias vdir='vdir --color=auto' alias grep='grep --color=auto' alias fgrep='fgrep --color=auto' alias egrep='egrep --color=auto' fi # colored GCC warnings and errors #export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01' # some more ls aliases alias ll='ls -alF' alias la='ls -A' alias l='ls -CF' # Add an \"alert\" alias for long running commands. Use like so: # sleep 10; alert alias alert='notify-send --urgency=low -i \"$([ $? = 0 ] && echo terminal || echo error)\" \"$(history|tail -n1|sed -e '\\''s/^\\s*[0-9]\\+\\s*//;s/[;&|]\\s*alert$//'\\'')\"' # Alias definitions. # You may want to put all your additions into a separate file like # ~/.bash_aliases, instead of adding them here directly. # See /usr/share/doc/bash-doc/examples in the bash-doc package. if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi # enable programmable completion features (you don't need to enable # this, if it's already enabled in /etc/bash.bashrc and /etc/profile # sources /etc/bash.bashrc). if ! shopt -oq posix; then if [ -f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion ]; then . /etc/bash_completion fi fi #proxy set export ClientIP=$(ip addr show eth0 | grep 'inet ' | awk '{print $2}' | cut -f 1 -d '/') export HostIP=$(cat /etc/resolv.conf | grep 'nameserver' | awk '{print $2}') showproxy() { echo '' echo 'Show Proxy:' echo \"http_proxy=$http_proxy\" echo \"https_proxy=$https_proxy\" echo \"ftp_proxy=$ftp_proxy\" echo \"ALL_PROXY=$ALL_PROXY\" echo '' } setproxy() { export http_proxy=http://$HostIP:10809/ export https_proxy=http://$HostIP:10809/ export ftp_proxy=http://$HostIP:10809/ export ALL_PROXY=socks5://$HostIP:10808/ git config --global http.proxy $ALL_PROXY git config --global https.proxy $ALL_PROXY showproxy echo \"curl --connect-timeout 5 google.com\" curl --connect-timeout 5 google.com } unsetproxy() { unset https_proxy unset http_proxy unset ftp_proxy unset ALL_PROXY git config --global --unset http.proxy git config --global --unset https.proxy showproxy echo \"curl --connect-timeout 5 163.com\" curl --connect-timeout 5 163.com } "}}